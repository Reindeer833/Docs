

                           STD::map
                           ========
						   


Associative Container
--------------------

Maps are associative containers that store elements formed by a combination of a key value and a mapped value, 
following a specific order.

In a map, the key values are used to sort and uniquely identify the elements. The types of key and mapped value are grouped together 
in member type value_type, a pair type combining both:

 typedef pair<const Key, T> value_type;
 
 Maps are implemented as binary search trees.

 Map does not have push_back so it does not have
   back_inserter
   
Map has:   size_type   

key_type     type of K
mapped_type  type of Mapped type
value_type   type of pair    (NOT OF VALUE!!!!)

allocator_type   //creates memory for pairs

   
~~~~~~~~~~~~~~~~
Member Functions
~~~~~~~~~~~~~~~~					   

map::key_type
map::mapped_type


Constructors
------------
std::map<int,int> map;  
std::map<string,string,bool (*)(string,string)> aMap(aCompFn);


Three erase functions:
---------------------
iterator  erase (const_iterator position); //  By iterator
size_type erase (const key_type& k);   //By key
iterator  erase (const_iterator first, const_iterator last);// By iterator range


Various iterators:
------------------

std::map<char,int>::iterator it=mymap.begin(); end();
                                      cbegin();cend();
				      rbegin();rend();
				      crbegin();crend();
									  
									  

									  
auto ret = mymap.insert ( std::pair<char,int>('a',100) );
if(ret.second == false{ ...this element already existed in the map ...}
// Notice that pair is templated
I can use:  make_par('a',23);//returns proper pair and is NOT templated

bool empty();
------------
size_t myMap.size();
--------------------

mymap.at(aKey)=aValue;
----------------------

std::map<char,std::string> mymap;
mymap['c']="hello";  //throws exeption if key does not exist
----------------------------------


iterator find (const key_type& k);
----------------------------------
It will return iterator to the the element with key
or, if this key does not exist, map.end();



allocator_type get_allocator();
-------------------------------

std::pair<const char,int>* p;           //allocator will assigne memory for pairs
p=mymap.get_allocator().allocate(5);    //allocate array of 5 pairs
mymap.get_allocator().deallocate(p,5);  //return memory

When we are using for_each ... to iterate through map<K,V>, return value 
is value_type or equivalently pair<K,V>
It is pair, not pointer to pair.
So in lambda or a function whose pointer we are using, we operate with:
arg.first
arg.second

template <typename K,typename V>
void cpMaps(map<K,V>& aA,multimap<V,K>& bB){
    for_each(aA.begin(),aA.end(),
        [&](pair<K,V> prkv){// in lambda argument I am using pair<K,V>
            bB.insert(pair<V,K>(prkv.second,prkv.first) );
        }
    );
}



