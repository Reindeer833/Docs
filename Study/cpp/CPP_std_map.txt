

                           STD::map
                           ========
						   


Associative Container
--------------------

Maps are associative containers that store elements formed by a combination of a key value and a mapped value, 
following a specific order.

In a map, the key values are used to sort and uniquely identify the elements. The types of key and mapped value are grouped together 
in member type value_type, a pair type combining both:

 typedef pair<const Key, T> value_type; //DO YOU SEE THAT CONST KEY ???

This though is wrong:      map<pair<const int,string> > abc;  //WRONG
 
 Maps are implemented as binary search trees.

 Map does not have push_back so it does not have
   back_inserter

Map constructor has at least two templates.
   
Map has:   size_type   

key_type     type of K
mapped_type  type of Mapped type
value_type   type of pair    (NOT OF VALUE!!!!)

allocator_type   //creates memory for pairs


IMPORTANT
---------

    map<const string,string> mStr;   //DO YOU SEE THAT CONST KEY ???   
    for(int ix=0;ix <10;++ix){
        string inP=to_string(ix);
        mStr.insert(pair<const string,string>(inP,inP));  //DO YOU SEE THAT CONST KEY ???   
    }
      auto mAll=mStr.get_allocator();                      //you may go with auto
//    pair<const string,string>* allPtr=mAll.allocate(5);  //DO YOU SEE THAT CONST KEY ???   

   
~~~~~~~~~~~~~~~~
Member Functions
~~~~~~~~~~~~~~~~					   

map::key_type
map::mapped_type


Constructors
------------
std::map<int,int> map;  
std::map<string,string,bool (*)(string,string)> aMap(aCompFn);

insert
~~~~~~
pair<iterator,bool> insert (const value_type& val);
---------------------------------------------------
auto aP = myMap.insert(somePair);
if(aP.second == false){
   ..........
}

insert multiples
----------------
void insert (InputIterator first, InputIterator last);



Checking if key exists
----------------------
an_iterator find (const key_type& k);
// if(an_iterator != myMap.end){ ... }


Three erase functions:
----------------------
size_type erase (const key_type& k);       //  By key
iterator  erase (const_iterator position); //  By iterator
iterator  erase (const_iterator first, const_iterator last);// By iterator range


Various iterators:
------------------

std::map<char,int>::iterator it=mymap.begin(); end();
                                      cbegin();cend();
				      rbegin();rend();
				      crbegin();crend();
									  
									  

									  
auto ret = mymap.insert ( std::pair<char,int>('a',100) );
if(ret.second == false{ ...this element already existed in the map ...}
// Notice that pair is templated
I can use:  make_par('a',23);//returns proper pair and make_pair is NOT templated

bool empty();
------------
size_t myMap.size();
--------------------

mymap.at(aKey)=aValue;
----------------------

std::map<char,std::string> mymap;
mymap['c']="hello";  //throws exeption if key does not exist
----------------------------------


iterator find (const key_type& k);
----------------------------------
It will return iterator to the the element with key
or, if this key does not exist, map.end();



allocator_type get_allocator();
-------------------------------

std::pair<const char,int>* p;           //allocator will assign memory for pairs
p=mymap.get_allocator().allocate(5);    //allocate array of 5 pairs
mymap.get_allocator().deallocate(p,5);  //return memory

When we are using for_each ... to iterate through map<K,V>, return value 
                 ---------
is value_type or equivalently pair<K,V>
   ---------
It is pair, not pointer to pair.
      ----      ------
So in lambda or a function whose pointer we are using, we operate with:
arg.first
arg.second

template <typename K,typename V>
void cpMaps(map<K,V>& aA,multimap<V,K>& bB){
    for_each(aA.begin(),aA.end(),
        [&](pair<K,V> prkv){// in lambda argument I am using pair<K,V>
            bB.insert(pair<V,K>(prkv.second,prkv.first) );
        }
    );
}




Example:
~~~~~~~~

void testMapAllocator(){
    map<const string,string> mStr;   //const key
    for(int ix=0;ix <10;++ix){
        string inP=to_string(ix);
        mStr.insert(pair<const string,string>(inP,inP));    //const key
    }
    auto mAll=mStr.get_allocator();
    pair<const string,string>* allPtr=mAll.allocate(5);    //const key
// Or: auto allPtr=mAll.allocate(5);
    
    uninitialized_copy(mStr.begin(),mStr.end(),allPtr);
    for(int ix=0;ix < 5;++ix){
          cout<<(allPtr+ix)->first<<"  "<<(allPtr+ix)->second<<endl;
    }
}

